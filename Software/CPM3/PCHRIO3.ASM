	TITLE	'CHARACTER I/O HANDLER FOR CP/M 3.0'

	; DEFINE LOGICAL VALUES:
TRUE		EQU	-1
FALSE		EQU	NOT TRUE

	; DETERMINE IF FOR BANK SELECT OR NOT:
BANKED		EQU	FALSE	;<------------------- BANKED VERSION

	; DEFINE PUBLIC LABELS:
	PUBLIC	?CINIT,?CI,?CO,?CIST,?COST
	PUBLIC	@CTBL

	; DEFINE EXTERNAL LABELS AND ENTRY POINTS:
	IF	BANKED
	EXTRN	@CBNK
	EXTRN	?BNKSL
	ENDIF
	EXTRN	?PMSG


	; EQUATES FOR MODE BYTE BIT FIELDS

MB$INPUT	EQU 0000$0001B	; DEVICE MAY DO INPUT
MB$OUTPUT	EQU 0000$0010B	; DEVICE MAY DO OUTPUT
MB$IN$OUT	EQU MB$INPUT+MB$OUTPUT

MB$SOFT$BAUD	EQU 0000$0100B	; SOFTWARE SELECTABLE BAUD RATES

MB$SERIAL	EQU 0000$1000B	; DEVICE MAY USE PROTOCOL
MB$XON$XOFF	EQU 0001$0000B	; XON/XOFF PROTOCOL ENABLED

BAUD$NONE	EQU 0		; NO BAUD RATE ASSOCIATED WITH THIS DEVICE
BAUD$50		EQU 1		; 50 BAUD
BAUD$75		EQU 2		; 75 BAUD
BAUD$110	EQU 3		; 110 BAUD
BAUD$134	EQU 4		; 134.5 BAUD
BAUD$150	EQU 5		; 150 BAUD
BAUD$300	EQU 6		; 300 BAUD
BAUD$600	EQU 7		; 600 BAUD
BAUD$1200	EQU 8		; 1200 BAUD
BAUD$1800	EQU 9		; 1800 BAUD
BAUD$2400	EQU 10		; 2400 BAUD
BAUD$3600	EQU 11		; 3600 BAUD
BAUD$4800	EQU 12		; 4800 BAUD
BAUD$7200	EQU 13		; 7200 BAUD
BAUD$9600	EQU 14		; 9600 BAUD
BAUD$19200	EQU 15		; 19.2K BAUD

; MiniSys Equates
shm$base equ 0fff0h
shm$cmd equ shm$base
shm$data equ shm$base + 1
shm$track equ shm$base + 3
shm$sect equ shm$base + 5
shm$dma equ shm$base + 7
shm$drive equ shm$base + 9
cmd$readsec equ 0
cmd$writesec equ 1
cmd$chkdisk equ 2

	; WILL START OFF IN COMMON MEMORY FOR BANKED OR NON-BANKED SYSTEMS:
	CSEG


	IF	BANKED
	; WE PROVIDE ALTERNATE DEFINITIONS OF THE ROUTINE ENTRY POINTS IF
	;  WE ARE RUNNING A BANKED SYSTEM VERSUS A NON-BANKED SYSTEM:

	;;;;; ?CINIT
	; ENTER HERE FOR BANKED SYSTEMS FOR DEVICE INITIALIZATIONS:
?CINIT:
	LXI	H,BCINIT	;POINT TO BANKED ROUTINE ADDRESS
	JR	BANKIO		;GO TO DISPATCHER

	;;;;; ?CI
	; ENTER HERE FOR BANKED SYSTEM DEVICE INPUT:
?CI:	LXI	H,BCI		;POINT TO BANKED ROUTINE ADDRESS
	JR	BANKIO		;GO TO DISPATCHER

	;;;;; ?CO
	; ENTER HERE FOR BANKED SYSTEM DEVICE OUTPUT:
?CO:	LXI	H,BCO		;POINT TO BANKED ROUTINE ADDRESS
	JR	BANKIO		;GO TO DISPATCHER

	;;;;; ?CIST
	; ENTER HERE FOR BANKED SYSTEM DEVICE INPUT STATUS:
?CIST:	LXI	H,BCIST		;POINT TO BANKED ROUTINE ADDRESS
	JR	BANKIO		;GO TO DISPATCHER

	;;;;; ?COST
	; ENTER HERE FOR BANKED SYSTEM DEVICE OUTPUT STATUS:
?COST:	LXI	H,BCOST		;POINT TO BANKED ROUTINE ADDRESS


	;;;;; BANKIO
	; ROUTINE DISPATCHES TO BANKED PORTION OF CHARACTER I/O ROUTINES:
BANKIO:
	SSPD	SPSAVE		;SAVE CURRENT STACK POINTER
	LXI	SP,IOSP		; AND USE LOCAL STACK FOR I/O
	LDA	@CBNK		;GET CURRENT BANK
	PUSH	PSW		;SAVE ON LOCAL STACK
	XRA	A		;WE WILL SELECT BANK 0 (OP SYS)
	CALL	?BNKSL
	LXI	D,BIORET	;RETURN ADDRESS IN [DE]
	PUSH	D		;PUT IT ON STACK FOR RETURN
	PCHL			;DISPATCH TO BANKED PART OF ROUTINE

	; ARRIVE HERE AFTER DEVICE HANDLER FINISHED:
BIORET:
	POP	D		;GET PREVIOUS CURRENT BANK TO [D]
	PUSH	PSW		;SAVE HANDLER RETURNED RESULT (IF ANY)
	MOV	A,D		;RESELECT PREVIOUS CURRENT BANK
	CALL	?BNKSL
	POP	PSW		;GET BACK RESULT CODE TO [A]
	LSPD	SPSAVE		;RESTORE PREVIOUS STACK
	RET			;AND RETURN...
	ENDIF


	;;;;;
	;;;;; ACTUAL DEVICE HANDLERS
	;;;;;


	;;;;; ?CINIT (BCINIT FOR BANKED)
	; PHYSICAL CODE FOR DEVICE INITIALIZATION:
	IF	BANKED
	DSEG			;CAN PUT IN BANKED SEGMENT IF BANKED
BCINIT:
	ELSE
?CINIT:
	ENDIF
	MOV	B,C		;ON ENTRY DEVICE # IS IN [C] BUT WE NEED
				;IT IN [B]
	CALL	DEV$DISPATCH	;GO TO CORRECT INIT ROUTINE
	DW	CINIT0		;INIT FOR DEVICE 0
	DW	NULL$INIT	;INIT FOR DEVICE 1
	DW	NULL$INIT	;INIT FOR DEVICE 2
	DW	NULL$INIT	;INIT FOR DEVICE 3
	DW	NULL$INIT	;INIT FOR DEVICE 4
	DW	NULL$INIT	;INIT FOR DEVICE 5
	DW	NULL$INIT	;INIT FOR DEVICE 6
	DW	NULL$INIT	;INIT FOR DEVICE 7
	DW	NULL$INIT	;INIT FOR DEVICE 8
	DW	NULL$INIT	;INIT FOR DEVICE 9
	DW	NULL$INIT	;INIT FOR DEVICE 10
	DW	NULL$INIT	;INIT FOR DEVICE 11
	DW	NULL$INIT	;INIT FOR DEVICE 12
	DW	NULL$INIT	;INIT FOR DEVICE 13
	DW	NULL$INIT	;INIT FOR DEVICE 14
	DW	NULL$INIT	;INIT FOR DEVICE 15


	;;;;; ?CI (BCI FOR BANKED)
	; PHYSICAL CODE FOR DEVICE INPUT:
	IF	BANKED
BCI:
	ELSE
?CI:
	ENDIF
	CALL	DEV$DISPATCH
	DW	CI0			;DEVICE 0 INPUT
	DW	NULL$CI		;DEVICE 1 INPUT
	DW	NULL$CI		;DEVICE 2 INPUT
	DW	NULL$CI		;DEVICE 3 INPUT
	DW	NULL$CI		;DEVICE 4 INPUT
	DW	NULL$CI		;DEVICE 5 INPUT
	DW	NULL$CI		;DEVICE 6 INPUT
	DW	NULL$CI		;DEVICE 7 INPUT
	DW	NULL$CI		;DEVICE 8 INPUT
	DW	NULL$CI		;DEVICE 9 INPUT
	DW	NULL$CI		;DEVICE 10 INPUT
	DW	NULL$CI		;DEVICE 11 INPUT
	DW	NULL$CI		;DEVICE 12 INPUT
	DW	NULL$CI		;DEVICE 13 INPUT
	DW	NULL$CI		;DEVICE 14 INPUT
	DW	NULL$CI		;DEVICE 15 INPUT


	;;;;; ?CO (BCO FOR BANKED)
	; PHYSICAL CODE FOR DEVICE OUTPUT:
	IF	BANKED
BCO:
	ELSE
?CO:
	ENDIF
	CALL	DEV$DISPATCH	;GO TO CORRECT DEVICE OUTPUT HANDLER
	DW	CO0			;DEVICE 0 OUTPUT
	DW	NULL$CO		;DEVICE 1 OUTPUT
	DW	NULL$CO		;DEVICE 2 OUTPUT
	DW	NULL$CO		;DEVICE 3 OUTPUT
	DW	NULL$CO		;DEVICE 4 OUTPUT
	DW	NULL$CO		;DEVICE 5 OUTPUT
	DW	NULL$CO		;DEVICE 6 OUTPUT
	DW	NULL$CO		;DEVICE 7 OUTPUT
	DW	NULL$CO		;DEVICE 8 OUTPUT
	DW	NULL$CO		;DEVICE 9 OUTPUT
	DW	NULL$CO		;DEVICE 10 OUTPUT
	DW	NULL$CO		;DEVICE 11 OUTPUT
	DW	NULL$CO		;DEVICE 12 OUTPUT
	DW	NULL$CO		;DEVICE 13 OUTPUT
	DW	NULL$CO		;DEVICE 14 OUTPUT
	DW	NULL$CO		;DEVICE 15 OUTPUT


	;;;;; ?CIST (BCIST FOR BANKED)
	; PHYSICAL CODE FOR DEVICE INPUT STATUS:
	IF	BANKED
BCIST:
	ELSE
?CIST:
	ENDIF
	CALL	DEV$DISPATCH
	DW	CIST0		;DEVICE 0 INPUT STATUS
	DW	NULL$CIST	;DEVICE 1 INPUT STATUS
	DW	NULL$CIST	;DEVICE 2 INPUT STATUS
	DW	NULL$CIST	;DEVICE 3 INPUT STATUS
	DW	NULL$CIST	;DEVICE 4 INPUT STATUS
	DW	NULL$CIST	;DEVICE 5 INPUT STATUS
	DW	NULL$CIST	;DEVICE 6 INPUT STATUS
	DW	NULL$CIST	;DEVICE 7 INPUT STATUS
	DW	NULL$CIST	;DEVICE 8 INPUT STATUS
	DW	NULL$CIST	;DEVICE 9 INPUT STATUS
	DW	NULL$CIST	;DEVICE 10 INPUT STATUS
	DW	NULL$CIST	;DEVICE 11 INPUT STATUS
	DW	NULL$CIST	;DEVICE 12 INPUT STATUS
	DW	NULL$CIST	;DEVICE 13 INPUT STATUS
	DW	NULL$CIST	;DEVICE 14 INPUT STATUS
	DW	NULL$CIST	;DEVICE 15 INPUT STATUS


	;;;;; ?COST (BCOST FOR BANKED)
	; PHYSICAL CODE FOR DEVICE OUTPUT STATUS:
	IF	BANKED
BCOST:
	ELSE
?COST:
	ENDIF
	CALL	DEV$DISPATCH	;GO TO CONSOLE OUTPUT STATUS HANDLER
	DW	COST0		;DEVICE 0 OUTPUT STATUS
	DW	NULL$COST	;DEVICE 1 OUTPUT STATUS
	DW	NULL$COST	;DEVICE 2 OUTPUT STATUS
	DW	NULL$COST	;DEVICE 3 OUTPUT STATUS
	DW	NULL$COST	;DEVICE 4 OUTPUT STATUS
	DW	NULL$COST	;DEVICE 5 OUTPUT STATUS
	DW	NULL$COST	;DEVICE 6 OUTPUT STATUS
	DW	NULL$COST	;DEVICE 7 OUTPUT STATUS
	DW	NULL$COST	;DEVICE 8 OUTPUT STATUS
	DW	NULL$COST	;DEVICE 9 OUTPUT STATUS
	DW	NULL$COST	;DEVICE 10 OUTPUT STATUS
	DW	NULL$COST	;DEVICE 11 OUTPUT STATUS
	DW	NULL$COST	;DEVICE 12 OUTPUT STATUS
	DW	NULL$COST	;DEVICE 13 OUTPUT STATUS
	DW	NULL$COST	;DEVICE 14 OUTPUT STATUS
	DW	NULL$COST	;DEVICE 15 OUTPUT STATUS


	;;;;; DEV$DISPATCH
	; ROUTINE JUMPS TO CORRECT DEVICE HANDLER:
DEV$DISPATCH:
	MOV	A,B		;GET DEVICE # TO [A]
	STA	DEV$CODE	;SAVE FOR LATER USE
	ADD	A		;X2 FOR WORD OFFSET
	POP	H		;RETURN ADDRESS IS 1ST PARAMETER ADDRESS
	MOV	E,A		;SET UP OFFSET IN [DE]
	MVI	D,0
	DAD	D		;[HL] = PTR TO HANDLER ADDRESS
	MOV	E,M		;GET HANDLER ADDRESS TO [DE]
	INX	H
	MOV	D,M
	XCHG			;PUT IN [HL]
	PCHL			;AND DISPATCH TO IT...


	;;;;;
	;;;;; PHYSICAL DEVICE HANDLER CODE:
	;;;;;
;

	;;;;; DEVICE 0 HANDLERS (MiniSys Console)
CINIT0:	; DEVICE 0 INITIALIZATION 
	RET
;
; 
;<<<<<<<<<<<<<<<<<<< MAIN CONSOL STATUS ROUTINE >>>>>>>>>>>>>>>>>>>>>>
CIST0:				; DEVICE 0 INPUT STATUS:
CSTS:
	in 0
	ani 1
	rz				; will be zero if nothing waiting
	xra a
	dcr a
	ret				; a = FF if something waiting
;
;
;<<<<<<<<<<<<<<<<<<<< MAIN CONSOL INPUT ROUTINE >>>>>>>>>>>>>>>>>>>>
;
CI0:				;DEVICE 0 INPUT:
CI:
	in 0
	ani 1
	jz CI			; wait for a char

	in 1			; get the char
	ANI	7FH			; mask off high bit
	RET
;
;<<<<<<<<<<<<<<<<<<<<<< MAIN CONSOL OUTPUT ROUTINE >>>>>>>>>>>>>>>>>>>>>>>>>
;
COST0:	; DEVICE 0 OUTPUT STATUS (Return FF if ready):
	in 0
	cma
	ani 02h
	rz
	xra a
	dcr a
	RET
;
CO0:				; DEVICE 0 OUTPUT:
CO:
	in 0
	ani 02h
	jnz CO0
	mov a,c
	out 1
	ret			; done
;
;
	;;;;; NULL ROUTINES:
NULL$CIST:
NULL$COST:
	XRA	A		;RETURN A FALSE STATUS RESULT
	RET
NULL$CI:
	MVI	A,1AH		;FOR INPUT RETURN A CNTL-Z (EOF)
NULL$INIT:
NULL$CO:
NULL$RET:
	RET			;HARMLESS RETURN


	; STORAGE FOR DEVICE CODE -- CAN RESIDE IN SAME SEGMENT AS THE BULK
	;  OF CHARACTER I/O ROUTINES:
DEV$CODE:	DS	1

	;;;;; CHRTBL
	; CHARACTER DEVICE TABLE
	CSEG			;MUST RESIDE IN COMMON MEMORY
@CTBL:
	DB	'CON   '		;CONSOLE (DEVICE 0)
	DB	MB$IN$OUT
	DB	BAUD$NONE

MAX$DEVICES	EQU	($-@CTBL)/8	;# DEVICES IN TABLE
	DB	0			;TABLE TERMINATOR


	; OTHER DATA AREAS:
	DS	24		;CHARACTER I/O LOCAL STACK
IOSP	EQU	$
SPSAVE	DS	2

	END
